/**
 * Generator class is a mathematical representation a cyclic group that is generated by an operation
 */
export class Generator{
    private operation : number[];

    /**
     * @constructor creates a generator set
     * @param {number[]} operation: array of numbers that define next position in cycle
     */
    constructor(operation : number[]) {
        if(!this.validOperation(operation)) {
            throw new Error("Invalid operation");
        }

        this.operation = operation;
    }

    /**
     * next is an isomporphic function that applies to generator operation on state parameter.
     * 
     * Let A: T -> array index and A is an isomorphic function
     * Let B: array index -> array index and B is the function that applies the operation on array
     * 
     * next(state) = ABA^(-1) (state)
     * 
     * @param {T[]} state: Array of type T with length as operation. (This is required in order for isomorphism)
     * @returns {T[]} the next state after the generator operation is applied
     */
    public next<T>(state : T[]) : T[] {
        if(state.length != this.operation.length) {
            throw new Error("state has an invalid size");
        }

        let nextState : T[] = new Array(state.length);
        
        this.operation.forEach((next, index) => {
            nextState[next] = state[index]
        });

        return nextState;
    }

    /**
     * validOperation checks if an operation would lead to a cyclic group
     * @param {number[]} operation
     * @returns {boolean} of whether operation is valid
     */
    private validOperation(operation : number[]) : boolean {
        let tmp : boolean[] = new Array(operation.length).fill(false);

        for(let i1 = 0; i1 < operation.length; i1++) {
            let next = operation[i1];

            //next value out of range
            if(next < 0 || tmp.length < next) {
                return false;
            }

            //double visit of index
            if(tmp[next]) {
                return false;
            }

            tmp[next] = true;
        }

        return true;
    }
}